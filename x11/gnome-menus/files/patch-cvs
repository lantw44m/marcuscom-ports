diff -ur gnome-menus-2.9.90/ChangeLog ChangeLog
--- gnome-menus-2.9.90/ChangeLog	Tue Jan 25 13:05:35 2005
+++ ChangeLog	Wed Feb 23 23:22:55 2005
@@ -1,3 +1,69 @@
+2005-02-24  Ankit Patel <ankit644@yahoo.com>
+
+	* configure.in: Added gu "Gujarati" in ALL_LINGUAS.
+
+2005-02-22  Arafat Medini  <kinryu@silverpen.de>
+
+	* configure.in: Added Arabic locale to ALL_LINGUAS.
+	
+2005-02-18  Mark McLoughlin  <mark@skynet.ie>
+
+	* libmenu/entry-directories.c:
+	(cached_dir_invoke_monitors): split out from
+	handle_cached_dir_changed() and invoke monitors on
+	ancestors too. Fixes bug #167759.
+	(handle_cached_dir_changed): upd.
+
+	* util/test-menu-spec.c: add a --monitor option
+	to test monitoring.
+
+2005-02-18  Mark McLoughlin  <mark@skynet.ie>
+
+	Fix bug with the <Not> directive - bug #167758.
+	Thanks to Chris Lahey for the test case.
+
+	* libmenu/entry-directories.c: (get_inverse_func): lookup
+	the entry using its file id rather than relative path.
+	
+	* libmenu/menu-tree.c:
+	(process_include_rules), (process_layout): add some more
+	debugging.
+
+2005-02-18  Mark McLoughlin  <mark@skynet.ie>
+
+	Make us pass most of the spec tests again.
+
+	* util/test-menu-spec.c:
+	(append_directory_path), (make_path): add a variant
+	of menu_tree_directory_make_path() - difference is
+	we use the directory name from the directory entry
+	if available. We don't want to do that in
+	menu_tree_directory_make_path() because that would
+	make the path locale dependant.
+	(print_directory): use it here.
+
+2005-02-14  Pawan Chitrakar  <pawan@nplinux.org>
+
+	* configure.in: Added ne "Nepali" in ALL_LINGUAS
+
+2005-02-13  Artur Flinta <aflinta@cvs.gnome.org>
+
+	* configure.in: Added "pl" to ALL_LINGUAS.
+
+2005-02-13  David Lodge <dave@cirt.net>
+
+	* configure.in: Added "en_GB" to ALL_LINGUAS.
+
+2005-02-12  Changwoo Ryu  <cwryu@debian.org>
+
+	* configure.in: Added "ko" to ALL_LINGUAS.
+
+2004-01-25  Vincent Untz  <vincent@vuntz.net>
+
+	* configure.in: post-release bump to 2.9.91.
+
+==================== 2.9.90 ====================
+
 2004-01-25  Vincent Untz  <vincent@vuntz.net>
 
 	* README, NEWS, configure.in: version 2.9.90
diff -ur gnome-menus-2.9.90/libmenu/entry-directories.c libmenu/entry-directories.c
--- gnome-menus-2.9.90/libmenu/entry-directories.c	Wed Jan  5 11:48:55 2005
+++ libmenu/entry-directories.c	Fri Feb 18 12:36:45 2005
@@ -430,6 +430,28 @@
 }
 
 static void
+cached_dir_invoke_monitors (CachedDir *dir)
+{
+  GSList *tmp;
+
+  tmp = dir->monitors;
+  while (tmp != NULL)
+    {
+      CachedDirMonitor *monitor = tmp->data;
+      GSList           *next    = tmp->next;
+
+      monitor->callback (monitor->ed, monitor->user_data);
+
+      tmp = next;
+    }
+
+  if (dir->parent)
+    {
+      cached_dir_invoke_monitors (dir->parent);
+    }
+}
+
+static void
 handle_cached_dir_changed (GnomeVFSMonitorHandle    *handle,
                            const char               *monitor_uri,
                            const char               *info_uri,
@@ -504,18 +526,7 @@
 
   if (handled)
     {
-      GSList *tmp;
-
-      tmp = dir->monitors;
-      while (tmp != NULL)
-        {
-          CachedDirMonitor *monitor = tmp->data;
-	  GSList           *next    = tmp->next;
-
-          monitor->callback (monitor->ed, monitor->user_data);
-
-          tmp = next;
-        }
+      cached_dir_invoke_monitors (dir);
     }
 }
 
@@ -1332,7 +1343,7 @@
 
   /* if not in the original set, add to inverse set */
 
-  if (desktop_entry_set_lookup (set, relative_path) != NULL)
+  if (desktop_entry_set_lookup (set, file_id ? file_id : relative_path) != NULL)
     return TRUE;
 
   if (ed->is_legacy && !desktop_entry_has_categories (entry))
diff -ur gnome-menus-2.9.90/libmenu/menu-tree.c libmenu/menu-tree.c
--- gnome-menus-2.9.90/libmenu/menu-tree.c	Wed Jan 12 14:23:52 2005
+++ libmenu/menu-tree.c	Fri Feb 18 11:17:51 2005
@@ -2108,6 +2108,8 @@
       {
         MenuLayoutNode *child;
 
+	menu_verbose ("Processing <And>\n");
+
         child = menu_layout_node_get_children (layout);
         while (child != NULL)
           {
@@ -2133,6 +2135,7 @@
 
             child = menu_layout_node_get_next (child);
           }
+	menu_verbose ("Processed <And>\n");
       }
       break;
 
@@ -2140,6 +2143,8 @@
       {
         MenuLayoutNode *child;
 
+	menu_verbose ("Processing <Or>\n");
+
         child = menu_layout_node_get_children (layout);
         while (child != NULL)
           {
@@ -2159,6 +2164,7 @@
 
             child = menu_layout_node_get_next (child);
           }
+	menu_verbose ("Processed <Or>\n");
       }
       break;
 
@@ -2167,6 +2173,8 @@
         /* First get the OR of all the rules */
         MenuLayoutNode *child;
 
+	menu_verbose ("Processing <Not>\n");
+
         child = menu_layout_node_get_children (layout);
         while (child != NULL)
           {
@@ -2192,18 +2200,24 @@
             /* Now invert the result */
             entry_directory_list_invert_set (list, set);
           }
+	menu_verbose ("Processed <Not>\n");
       }
       break;
 
     case MENU_LAYOUT_NODE_ALL:
+      menu_verbose ("Processing <All>\n");
       set = desktop_entry_set_new ();
       entry_directory_list_get_all_desktops (list, set);
+      menu_verbose ("Processed <All>\n");
       break;
 
     case MENU_LAYOUT_NODE_FILENAME:
       {
         DesktopEntry *entry;
 
+	menu_verbose ("Processing <Filename>%s</Filename>\n",
+		      menu_layout_node_get_content (layout));
+
         entry = entry_directory_list_get_desktop (list,
                                                   menu_layout_node_get_content (layout));
         if (entry != NULL)
@@ -2214,14 +2228,20 @@
                                          menu_layout_node_get_content (layout));
             desktop_entry_unref (entry);
           }
+	menu_verbose ("Processed <Filename>%s</Filename>\n",
+		      menu_layout_node_get_content (layout));
       }
       break;
 
     case MENU_LAYOUT_NODE_CATEGORY:
+      menu_verbose ("Processing <Category>%s</Category>\n",
+		    menu_layout_node_get_content (layout));
       set = desktop_entry_set_new ();
       entry_directory_list_get_by_category (list,
                                             menu_layout_node_get_content (layout),
                                             set);
+      menu_verbose ("Processed <Category>%s</Category>\n",
+		    menu_layout_node_get_content (layout));
       break;
 
     default:
@@ -2231,6 +2251,8 @@
   if (set == NULL)
     set = desktop_entry_set_new (); /* create an empty set */
 
+  menu_verbose ("Matched %d entries\n", desktop_entry_set_get_count (set));
+
   return set;
 }
 
@@ -2301,6 +2323,8 @@
           {
             MenuTreeDirectory *child_dir;
 
+	    menu_verbose ("Processing <Menu>\n");
+
             child_dir = process_layout (tree,
                                         directory,
                                         layout_iter,
@@ -2308,6 +2332,8 @@
             if (child_dir)
               directory->subdirs = g_slist_prepend (directory->subdirs,
                                                     child_dir);
+
+	    menu_verbose ("Processed <Menu>\n");
           }
           break;
 
@@ -2319,6 +2345,9 @@
              */
             MenuLayoutNode *rule;
 
+	    menu_verbose ("Processing <Include> (%d entries)\n",
+			  desktop_entry_set_get_count (entries));
+
             rule = menu_layout_node_get_children (layout_iter);
             while (rule != NULL)
               {
@@ -2334,6 +2363,9 @@
 
                 rule = menu_layout_node_get_next (rule);
               }
+
+	    menu_verbose ("Processed <Include> (%d entries)\n",
+			  desktop_entry_set_get_count (entries));
           }
           break;
 
@@ -2345,6 +2377,9 @@
              */
             MenuLayoutNode *rule;
 
+	    menu_verbose ("Processing <Exclude> (%d entries)\n",
+			  desktop_entry_set_get_count (entries));
+
             rule = menu_layout_node_get_children (layout_iter);
             while (rule != NULL)
               {
@@ -2359,6 +2394,9 @@
 
                 rule = menu_layout_node_get_next (rule);
               }
+
+	    menu_verbose ("Processed <Exclude> (%d entries)\n",
+			  desktop_entry_set_get_count (entries));
           }
           break;
 
@@ -2366,7 +2404,10 @@
           {
             DesktopEntry *entry;
 
-            /*
+	    menu_verbose ("Processed <Directory>%s</Directory>\n",
+			  menu_layout_node_get_content (layout_iter));
+
+	    /*
              * The last <Directory> to exist wins, so we always try overwriting
              */
             entry = entry_directory_list_get_directory (dir_dirs,
@@ -2392,18 +2433,22 @@
           break;
 
         case MENU_LAYOUT_NODE_DELETED:
+	  menu_verbose ("Processed <Deleted/>\n");
           deleted = TRUE;
           break;
 
         case MENU_LAYOUT_NODE_NOT_DELETED:
+	  menu_verbose ("Processed <NotDeleted/>\n");
           deleted = FALSE;
           break;
 
         case MENU_LAYOUT_NODE_ONLY_UNALLOCATED:
+	  menu_verbose ("Processed <OnlyUnallocated/>\n");
           only_unallocated = TRUE;
           break;
 
         case MENU_LAYOUT_NODE_NOT_ONLY_UNALLOCATED:
+	  menu_verbose ("Processed <NotOnlyUnallocated/>\n");
           only_unallocated = FALSE;
           break;
 
diff -ur gnome-menus-2.9.90/util/test-menu-spec.c util/test-menu-spec.c
--- gnome-menus-2.9.90/util/test-menu-spec.c	Sat Dec 11 09:26:49 2004
+++ util/test-menu-spec.c	Fri Feb 18 12:36:45 2005
@@ -24,6 +24,49 @@
 #include <string.h>
 #include <libgnomevfs/gnome-vfs.h>
 
+static gboolean monitor = FALSE;
+
+static GOptionEntry options[] = {
+  { "monitor", 'm', 0, G_OPTION_ARG_NONE, &monitor, "Monitor for menu changes", NULL },
+  { NULL }
+};
+
+static void
+append_directory_path (MenuTreeDirectory *directory,
+		       GString           *path)
+{
+  MenuTreeDirectory *parent;
+
+  parent = menu_tree_directory_get_parent (directory);
+
+  if (!parent)
+    {
+      g_string_append_c (path, '/');
+      return;
+    }
+
+  append_directory_path (parent, path);
+
+  g_string_append (path, menu_tree_directory_get_name (directory));
+  g_string_append_c (path, '/');
+
+  menu_tree_directory_unref (parent);
+}
+
+static char *
+make_path (MenuTreeDirectory *directory)
+{
+  GString *path;
+
+  g_return_val_if_fail (directory != NULL, NULL);
+
+  path = g_string_new (NULL);
+
+  append_directory_path (directory, path);
+
+  return g_string_free (path, FALSE);
+}
+
 static void
 print_directory (MenuTreeDirectory *directory)
 {
@@ -33,7 +76,7 @@
   const char *path;
   char       *freeme;
 
-  freeme = menu_tree_directory_make_path (directory, NULL);
+  freeme = make_path (directory);
   if (!strcmp (freeme, "/"))
     path = freeme;
   else
@@ -76,14 +119,37 @@
   g_free (freeme);
 }
 
+static void
+handle_tree_changed (MenuTree *tree)
+{
+  MenuTreeDirectory *root;
+
+  g_print ("\n\n\n==== Menu changed, reloading ====\n\n\n");
+
+  root = menu_tree_get_root_directory (tree);
+  if (root == NULL)
+    {
+      g_warning ("Menu tree is empty");
+      return;
+    }
+
+  print_directory (root);
+  menu_tree_directory_unref (root);
+}
+
 int
 main (int argc, char **argv)
 {
-  MenuTreeDirectory *root;
+  GOptionContext    *options_context;
   MenuTree          *tree;
+  MenuTreeDirectory *root;
 
   gnome_vfs_init ();
 
+  options_context = g_option_context_new ("- test GNOME's implementation of the Desktop Menu Specification");
+  g_option_context_add_main_entries (options_context, options, GETTEXT_PACKAGE);
+  g_option_context_parse (options_context, &argc, &argv, NULL);
+
   tree = menu_tree_lookup ("applications.menu");
   if (tree == NULL)
     {
@@ -93,17 +159,34 @@
     }
 
   root = menu_tree_get_root_directory (tree);
-  if (root == NULL)
+  if (root != NULL)
+    {
+      print_directory (root);
+      menu_tree_directory_unref (root);
+    }
+  else
     {
       g_warning ("Menu tree is empty");
-      menu_tree_unref (tree);
-      gnome_vfs_shutdown ();
-      return 0;
     }
 
-  print_directory (root);
+  if (monitor)
+    {
+      GMainLoop *main_loop;
+
+      menu_tree_add_monitor (tree,
+			     (MenuTreeChangedFunc) handle_tree_changed,
+			     NULL);
+
+      main_loop = g_main_loop_new (NULL, FALSE);
+      g_main_loop_run (main_loop);
+      g_main_loop_unref (main_loop);
+
+      menu_tree_remove_monitor (tree,
+				(MenuTreeChangedFunc) handle_tree_changed,
+				NULL);
+
+    }
 
-  menu_tree_directory_unref (root);
   menu_tree_unref (tree);
 
   gnome_vfs_shutdown ();
