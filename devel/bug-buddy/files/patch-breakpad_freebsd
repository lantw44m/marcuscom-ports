diff -rupN client.orig/freebsd/handler/exception_handler.cc client/freebsd/handler/exception_handler.cc
--- google-breakpad/src/client.orig/freebsd/handler/exception_handler.cc	1969-12-31 19:00:00.000000000 -0500
+++ google-breakpad/src/client/freebsd/handler/exception_handler.cc	2007-08-05 13:54:19.000000000 -0400
@@ -0,0 +1,265 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <signal.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <cassert>
+#include <cstdlib>
+#include <ctime>
+
+#include "client/linux/handler/exception_handler.h"
+#include "common/linux/guid_creator.h"
+#include "google_breakpad/common/minidump_format.h"
+
+namespace google_breakpad {
+
+// Signals that we are interested.
+int SigTable[] = {
+#if defined(SIGSEGV)
+  SIGSEGV,
+#endif
+#ifdef SIGABRT
+  SIGABRT,
+#endif
+#ifdef SIGFPE
+  SIGFPE,
+#endif
+#ifdef SIGILL
+  SIGILL,
+#endif
+#ifdef SIGBUS
+  SIGBUS,
+#endif
+};
+
+std::vector<ExceptionHandler*> *ExceptionHandler::handler_stack_ = NULL;
+int ExceptionHandler::handler_stack_index_ = 0;
+pthread_mutex_t ExceptionHandler::handler_stack_mutex_ =
+PTHREAD_MUTEX_INITIALIZER;
+
+ExceptionHandler::ExceptionHandler(const string &dump_path,
+                                   FilterCallback filter,
+                                   MinidumpCallback callback,
+                                   void *callback_context,
+                                   bool install_handler)
+    : filter_(filter),
+      callback_(callback),
+      callback_context_(callback_context),
+      dump_path_(),
+      installed_handler_(install_handler) {
+  set_dump_path(dump_path);
+
+  if (install_handler) {
+    SetupHandler();
+    pthread_mutex_lock(&handler_stack_mutex_);
+    if (handler_stack_ == NULL)
+      handler_stack_ = new std::vector<ExceptionHandler *>;
+    handler_stack_->push_back(this);
+    pthread_mutex_unlock(&handler_stack_mutex_);
+  }
+}
+
+ExceptionHandler::~ExceptionHandler() {
+  TeardownAllHandler();
+  pthread_mutex_lock(&handler_stack_mutex_);
+  if (handler_stack_->back() == this) {
+    handler_stack_->pop_back();
+  } else {
+    fprintf(stderr, "warning: removing Breakpad handler out of order\n");
+    for (std::vector<ExceptionHandler *>::iterator iterator =
+         handler_stack_->begin();
+         iterator != handler_stack_->end();
+         ++iterator) {
+      if (*iterator == this) {
+        handler_stack_->erase(iterator);
+      }
+    }
+  }
+
+  if (handler_stack_->empty()) {
+    // When destroying the last ExceptionHandler that installed a handler,
+    // clean up the handler stack.
+    delete handler_stack_;
+    handler_stack_ = NULL;
+  }
+  pthread_mutex_unlock(&handler_stack_mutex_);
+}
+
+bool ExceptionHandler::WriteMinidump() {
+  return InternalWriteMinidump(0, 0, NULL);
+}
+
+// static
+bool ExceptionHandler::WriteMinidump(const string &dump_path,
+                   MinidumpCallback callback,
+                   void *callback_context) {
+  ExceptionHandler handler(dump_path, NULL, callback,
+                           callback_context, false);
+  return handler.InternalWriteMinidump(0, 0, NULL);
+}
+
+void ExceptionHandler::SetupHandler() {
+  // Signal on a different stack to avoid using the stack
+  // of the crashing thread.
+  struct sigaltstack sig_stack;
+  sig_stack.ss_sp = (char *) malloc(MINSIGSTKSZ);
+  if (sig_stack.ss_sp == NULL)
+    return;
+  sig_stack.ss_size = MINSIGSTKSZ;
+  sig_stack.ss_flags = 0;
+
+  if (sigaltstack(&sig_stack, NULL) < 0)
+    return;
+  for (size_t i = 0; i < sizeof(SigTable) / sizeof(SigTable[0]); ++i)
+    SetupHandler(SigTable[i]);
+}
+
+void ExceptionHandler::SetupHandler(int signo) {
+  struct sigaction act, old_act;
+  act.sa_handler = HandleException;
+  act.sa_flags = SA_ONSTACK;
+  if (sigaction(signo, &act, &old_act) < 0)
+    return;
+  old_handlers_[signo] = old_act.sa_handler;
+}
+
+void ExceptionHandler::TeardownHandler(int signo) {
+  if (old_handlers_.find(signo) != old_handlers_.end()) {
+    struct sigaction act;
+    act.sa_handler = old_handlers_[signo];
+    act.sa_flags = 0;
+    sigaction(signo, &act, 0);
+  }
+}
+
+void ExceptionHandler::TeardownAllHandler() {
+  for (size_t i = 0; i < sizeof(SigTable) / sizeof(SigTable[0]); ++i) {
+    TeardownHandler(SigTable[i]);
+  }
+}
+
+// static
+void ExceptionHandler::HandleException(int signo) {
+  // In Linux, the context information about the signal is put on the stack of
+  // the signal handler frame as value parameter. For some reasons, the
+  // prototype of the handler doesn't declare this information as parameter, we
+  // will do it by hand. It is the second parameter above the signal number.
+  // However, if we are being called by another signal handler passing the
+  // signal up the chain, then we may not have this random extra parameter,
+  // so we may have to walk the stack to find it.  We do the actual work
+  // on another thread, where it's a little safer, but we want the ebp
+  // from this frame to find it.
+  uintptr_t current_ebp = 0;
+  asm volatile ("movl %%ebp, %0"
+                :"=m"(current_ebp));
+
+  pthread_mutex_lock(&handler_stack_mutex_);
+  ExceptionHandler *current_handler =
+    handler_stack_->at(handler_stack_->size() - ++handler_stack_index_);
+  pthread_mutex_unlock(&handler_stack_mutex_);
+
+  // Restore original handler.
+  current_handler->TeardownHandler(signo);
+
+  struct sigcontext *sig_ctx = NULL;
+  if (current_handler->InternalWriteMinidump(signo, current_ebp, &sig_ctx)) {
+    // Fully handled this exception, safe to exit.
+    exit(EXIT_FAILURE);
+  } else {
+    // Exception not fully handled, will call the next handler in stack to
+    // process it.
+    typedef void (*SignalHandler)(int signo, struct sigcontext);
+    SignalHandler old_handler =
+      reinterpret_cast<SignalHandler>(current_handler->old_handlers_[signo]);
+    if (old_handler != NULL && sig_ctx != NULL)
+      old_handler(signo, *sig_ctx);
+  }
+
+  pthread_mutex_lock(&handler_stack_mutex_);
+  current_handler->SetupHandler(signo);
+  --handler_stack_index_;
+  // All the handlers in stack have been invoked to handle the exception,
+  // normally the process should be terminated and should not reach here.
+  // In case we got here, ask the OS to handle it to avoid endless loop,
+  // normally the OS will generate a core and termiate the process. This
+  // may be desired to debug the program.
+  if (handler_stack_index_ == 0)
+    signal(signo, SIG_DFL);
+  pthread_mutex_unlock(&handler_stack_mutex_);
+}
+
+bool ExceptionHandler::InternalWriteMinidump(int signo,
+                                             uintptr_t sighandler_ebp,
+                                             struct sigcontext **sig_ctx) {
+  if (filter_ && !filter_(callback_context_))
+    return false;
+
+  GUID guid;
+  bool success = false;;
+  char guid_str[kGUIDStringLength + 1];
+  if (CreateGUID(&guid) && GUIDToString(&guid, guid_str, sizeof(guid_str))) {
+    char minidump_path[PATH_MAX];
+    snprintf(minidump_path, sizeof(minidump_path), "%s/%s.dmp",
+             dump_path_c_,
+             guid_str);
+
+    // Block all the signals we want to process when writting minidump.
+    // We don't want it to be interrupted.
+    sigset_t sig_blocked, sig_old;
+    bool blocked = true;
+    sigfillset(&sig_blocked);
+    for (size_t i = 0; i < sizeof(SigTable) / sizeof(SigTable[0]); ++i)
+      sigdelset(&sig_blocked, SigTable[i]);
+    if (sigprocmask(SIG_BLOCK, &sig_blocked, &sig_old) != 0) {
+      blocked = false;
+      fprintf(stderr, "google_breakpad::ExceptionHandler::HandleException: "
+                      "failed to block signals.\n");
+    }
+
+    success = minidump_generator_.WriteMinidumpToFile(
+                       minidump_path, signo, sighandler_ebp, sig_ctx);
+
+    // Unblock the signals.
+    if (blocked) {
+      sigprocmask(SIG_SETMASK, &sig_old, &sig_old);
+    }
+
+    if (callback_)
+      success = callback_(dump_path_c_, guid_str,
+                          callback_context_, success);
+  }
+  return success;
+}
+
+}  // namespace google_breakpad
diff -rupN client.orig/freebsd/handler/exception_handler.h client/freebsd/handler/exception_handler.h
--- google-breakpad/src/client.orig/freebsd/handler/exception_handler.h	1969-12-31 19:00:00.000000000 -0500
+++ google-breakpad/src/client/freebsd/handler/exception_handler.h	2007-08-05 13:54:19.000000000 -0400
@@ -0,0 +1,201 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H__
+#define CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H__
+
+#include <pthread.h>
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "client/linux/handler/minidump_generator.h"
+
+// Context information when exception occured.
+struct sigcontex;
+
+namespace google_breakpad {
+
+using std::string;
+
+//
+// ExceptionHandler
+//
+// ExceptionHandler can write a minidump file when an exception occurs,
+// or when WriteMinidump() is called explicitly by your program.
+//
+// To have the exception handler write minidumps when an uncaught exception
+// (crash) occurs, you should create an instance early in the execution
+// of your program, and keep it around for the entire time you want to
+// have crash handling active (typically, until shutdown).
+// (NOTE): There should be only be one this kind of exception handler
+// object per process.
+//
+// If you want to write minidumps without installing the exception handler,
+// you can create an ExceptionHandler with install_handler set to false,
+// then call WriteMinidump.  You can also use this technique if you want to
+// use different minidump callbacks for different call sites.
+//
+// In either case, a callback function is called when a minidump is written,
+// which receives the unqiue id of the minidump.  The caller can use this
+// id to collect and write additional application state, and to launch an
+// external crash-reporting application.
+//
+// Caller should try to make the callbacks as crash-friendly as possible,
+// it should avoid use heap memory allocation as much as possible.
+//
+class ExceptionHandler {
+ public:
+  // A callback function to run before Breakpad performs any substantial
+  // processing of an exception.  A FilterCallback is called before writing
+  // a minidump.  context is the parameter supplied by the user as
+  // callback_context when the handler was created.
+  //
+  // If a FilterCallback returns true, Breakpad will continue processing,
+  // attempting to write a minidump.  If a FilterCallback returns false,
+  // Breakpad  will immediately report the exception as unhandled without
+  // writing a minidump, allowing another handler the opportunity to handle it.
+  typedef bool (*FilterCallback)(void *context);
+
+  // A callback function to run after the minidump has been written.
+  // minidump_id is a unique id for the dump, so the minidump
+  // file is <dump_path>\<minidump_id>.dmp.  context is the parameter supplied
+  // by the user as callback_context when the handler was created.  succeeded
+  // indicates whether a minidump file was successfully written.
+  //
+  // If an exception occurred and the callback returns true, Breakpad will
+  // treat the exception as fully-handled, suppressing any other handlers from
+  // being notified of the exception.  If the callback returns false, Breakpad
+  // will treat the exception as unhandled, and allow another handler to handle
+  // it. If there are no other handlers, Breakpad will report the exception to
+  // the system as unhandled, allowing a debugger or native crash dialog the
+  // opportunity to handle the exception.  Most callback implementations
+  // should normally return the value of |succeeded|, or when they wish to
+  // not report an exception of handled, false.  Callbacks will rarely want to
+  // return true directly (unless |succeeded| is true).
+  typedef bool (*MinidumpCallback)(const char *dump_path,
+                                   const char *minidump_id,
+                                   void *context,
+                                   bool succeeded);
+
+  // Creates a new ExceptionHandler instance to handle writing minidumps.
+  // Before writing a minidump, the optional filter callback will be called.
+  // Its return value determines whether or not Breakpad should write a
+  // minidump.  Minidump files will be written to dump_path, and the optional
+  // callback is called after writing the dump file, as described above.
+  // If install_handler is true, then a minidump will be written whenever
+  // an unhandled exception occurs.  If it is false, minidumps will only
+  // be written when WriteMinidump is called.
+  ExceptionHandler(const string &dump_path,
+                   FilterCallback filter, MinidumpCallback callback,
+                   void *callback_context,
+                   bool install_handler);
+  ~ExceptionHandler();
+
+  // Get and set the minidump path.
+  string dump_path() const { return dump_path_; }
+  void set_dump_path(const string &dump_path) {
+    dump_path_ = dump_path;
+    dump_path_c_ = dump_path_.c_str();
+  }
+
+  // Writes a minidump immediately.  This can be used to capture the
+  // execution state independently of a crash.  Returns true on success.
+  bool WriteMinidump();
+
+  // Convenience form of WriteMinidump which does not require an
+  // ExceptionHandler instance.
+  static bool WriteMinidump(const string &dump_path,
+                            MinidumpCallback callback,
+                            void *callback_context);
+
+ private:
+  // Setup crash handler.
+  void SetupHandler();
+  // Setup signal handler for a signal.
+  void SetupHandler(int signo);
+  // Teardown the handler for a signal.
+  void TeardownHandler(int signo);
+  // Teardown all handlers.
+  void TeardownAllHandler();
+
+  // Signal handler.
+  static void HandleException(int signo);
+
+  // If called from a signal handler, sighandler_ebp is the ebp of
+  // that signal handler's frame, and sig_ctx is an out parameter
+  // that will be set to point at the sigcontext that was placed
+  // on the stack by the kernel.  You can pass zero and NULL
+  // for the second and third parameters if you are not calling
+  // this from a signal handler.
+  bool InternalWriteMinidump(int signo, uintptr_t sighandler_ebp,
+                             struct sigcontext **sig_ctx);
+
+ private:
+  FilterCallback filter_;
+  MinidumpCallback callback_;
+  void *callback_context_;
+
+  // The directory in which a minidump will be written, set by the dump_path
+  // argument to the constructor, or set_dump_path.
+  string dump_path_;
+  // C style dump path. Keep this when setting dump path, since calling
+  // c_str() of std::string when crashing may not be safe.
+  const char *dump_path_c_;
+
+  // True if the ExceptionHandler installed an unhandled exception filter
+  // when created (with an install_handler parameter set to true).
+  bool installed_handler_;
+
+  // Keep the previous handlers for the signal.
+  typedef void (*sighandler_t)(int);
+  std::map<int, sighandler_t> old_handlers_;
+
+  // The global exception handler stack. This is need becuase there may exist
+  // multiple ExceptionHandler instances in a process. Each will have itself
+  // registered in this stack.
+  static std::vector<ExceptionHandler *> *handler_stack_;
+  // The index of the handler that should handle the next exception.
+  static int handler_stack_index_;
+  static pthread_mutex_t handler_stack_mutex_;
+
+  // The minidump generator.
+  MinidumpGenerator minidump_generator_;
+
+  // disallow copy ctor and operator=
+  explicit ExceptionHandler(const ExceptionHandler &);
+  void operator=(const ExceptionHandler &);
+};
+
+}  // namespace google_breakpad
+
+#endif  // CLIENT_LINUX_HANDLER_EXCEPTION_HANDLER_H__
diff -rupN client.orig/freebsd/handler/minidump_generator.cc client/freebsd/handler/minidump_generator.cc
--- google-breakpad/src/client.orig/freebsd/handler/minidump_generator.cc	1969-12-31 19:00:00.000000000 -0500
+++ google-breakpad/src/client/freebsd/handler/minidump_generator.cc	2007-08-05 13:57:11.000000000 -0400
@@ -0,0 +1,66 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <fcntl.h>
+#include <pthread.h>
+#include <signal.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/utsname.h>
+#include <sys/wait.h>
+
+#include <cstdlib>
+#include <ctime>
+
+#include "google_breakpad/common/minidump_format.h"
+#include "client/freebsd/handler/minidump_generator.h"
+
+namespace google_breakpad {
+
+MinidumpGenerator::MinidumpGenerator() {
+  AllocateStack();
+}
+
+MinidumpGenerator::~MinidumpGenerator() {
+}
+
+void MinidumpGenerator::AllocateStack() {
+}
+
+bool MinidumpGenerator::WriteMinidumpToFile(const char *file_pathname,
+                                   int signo,
+                                   uintptr_t sighandler_ebp,
+                                   struct sigcontext **sig_ctx) const {
+  return false;
+}
+
+}  // namespace google_breakpad
diff -rupN client.orig/freebsd/handler/minidump_generator.h client/freebsd/handler/minidump_generator.h
--- google-breakpad/src/client.orig/freebsd/handler/minidump_generator.h	1969-12-31 19:00:00.000000000 -0500
+++ google-breakpad/src/client/freebsd/handler/minidump_generator.h	2007-08-05 13:57:45.000000000 -0400
@@ -0,0 +1,67 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Author: Li Liu
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef CLIENT_LINUX_HANDLER_MINIDUMP_GENERATOR_H__
+#define CLIENT_LINUX_HANDLER_MINIDUMP_GENERATOR_H__
+
+#include <stdint.h>
+
+#include "google_breakpad/common/breakpad_types.h"
+#include "processor/scoped_ptr.h"
+
+namespace google_breakpad {
+
+//
+// MinidumpGenerator
+//
+// Write a minidump to file based on the signo and sig_ctx.
+// A minidump generator should be created before any exception happen.
+//
+class MinidumpGenerator {
+  public:
+   MinidumpGenerator();
+
+   ~MinidumpGenerator();
+
+   // Write minidump.
+   bool WriteMinidumpToFile(const char *file_pathname,
+                            int signo,
+                            uintptr_t sighandler_ebp,
+                            struct sigcontext **sig_ctx) const;
+  private:
+   // Allocate memory for stack.
+   void AllocateStack();
+
+};
+
+}  // namespace google_breakpad
+
+#endif   // CLIENT_LINUX_HANDLER_MINIDUMP_GENERATOR_H__
